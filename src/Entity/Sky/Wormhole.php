<?php

namespace App\Entity\Sky;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;
use Doctrine\ORM\Event\PreFlushEventArgs;
use Doctrine\ORM\Event\PostLoadEventArgs;

use App\Entity\DataNode;

#[ORM\Entity]
#[ORM\Table(name: 'Wormhole')]
#[ORM\HasLifecycleCallbacks]
class Wormhole {
	#[ORM\Id]
	#[ORM\GeneratedValue]
	#[ORM\Column(type: 'integer')]
	private int $id;
	
	private bool $isDefined = false;
	private bool $isAutogenerated = false;
	
	#[ORM\ManyToOne(targetEntity: 'App\Entity\Sky\Planet')]
	#[ORM\JoinColumn(nullable: true, name: 'planetId')]
	private ?Planet $planet = null;
	#[ORM\Column(type: 'string')]
	private string $name = "???";
	#[ORM\Column(type: 'string')]
	private string $trueName = "";
	#[ORM\Column(type: 'boolean')]
	private bool $mappable = false;
	#[ORM\ManyToOne(targetEntity: 'App\Entity\Sky\Color', cascade: ['persist'])]
	#[ORM\JoinColumn(nullable: false, name: 'linkColorId')]
	private Color $linkColor; // ExclusiveItem<Color>
	private array $links = []; // unordered_map<const System *, const System *>

    #[ORM\OneToMany(mappedBy: 'wormhole', targetEntity: WormholeLink::class, orphanRemoval: true, cascade: ['persist'])]
    private Collection $linkObjects;
	
	#[ORM\Column(type: 'string')]
	private string $sourceName = '';
	#[ORM\Column(type: 'string')]
	private string $sourceFile = '';
	#[ORM\Column(type: 'string')]
	private string $sourceVersion = '';
	
	#[ORM\PreFlush]
	public function toDatabase(PreFlushEventArgs $eventArgs) {
		$handledLinks = [];
		foreach ($this->linkObjects as $Link) {
			$handled = false;
			if (isset($this->links[$Link->getFromSystem()->getName()])) {
				$handled = $this->links[$Link->getFromSystem()->getName()] == $Link->getToSystem();
				$handledLinks[$Link->getFromSystem()->getName()] = $Link->getToSystem()->getName();
			}
			if (!$handled) {
				$eventArgs->getObjectManager()->remove($Link);
			}
		}
		foreach ($this->links as $fromName => $ToSystem) {
			if (isset($handledLinks[$fromName]) && $handledLinks[$fromName] == $ToSystem->getName()) {
				continue;
			}
			$FromSystem = GameData::Systems()[$fromName];
			$Link = new WormholeLink();
			$Link->setWormhole($this);
			$Link->setFromSystem($FromSystem);
			$Link->setToSystem($ToSystem);
			$this->linkObjects []= $Link;
			$eventArgs->getObjectManager()->persist($Link);
		}
	}
	
	#[ORM\PostLoad]
	public function fromDatabase(PostLoadEventArgs $eventArgs) {
		foreach ($this->linkObjects as $Link) {
			$this->links[$Link->getFromSystem()->getName()] = $Link->getToSystem();
		}
	}
	
	const DEFAULT_WORMHOLE_COLOR = "map wormhole";
	
	// Define the constructor to set "linkColor" to the desired default color.
	public function __construct() {
		$this->linkColor = GameData::Colors()[self::DEFAULT_WORMHOLE_COLOR];
		$this->linkObjects = new ArrayCollection();
	}
	
	// Load a wormhole's description from a file.
	public function load(DataNode $node) {
		if ($node->size() < 2) {
			return;
		}
		$this->isDefined = true;
		$this->isAutogenerated = false;
		
		$this->trueName = $node->getToken(1);
		if ($node->getSourceName()) {
			$this->sourceName = $node->getSourceName();
			$this->sourceFile = $node->getSourceFile();
			$this->sourceVersion = $node->getSourceVersion();
		}
	
		$seenLinkAttribute = false;
		foreach ($node as $child) {
			// Check for the "add" or "remove" keyword.
			$add = ($child->getToken(0) == "add");
			$remove = ($child->getToken(0) == "remove");
			if (($add || $remove) && $child->size() < 2) {
				$child->printTrace("Skipping " + $child->getToken(0) + " with no key given:");
				continue;
			}
	
			// Get the key and value (if any).
			$key = $child->getToken(($add || $remove) ? 1 : 0);
			$valueIndex = ($add || $remove) ? 2 : 1;
			$hasValue = ($child->size() > $valueIndex);
			$value = $child->getToken($hasValue ? $valueIndex : 0);
	
			// Check for conditions that require clearing this key's current value.
			// "remove <key>" means to clear the key's previous contents.
			// "remove <key> <value>" means to remove just that value from the key.
			if (($remove && !$hasValue) && $key == "link") {
				$this->links = [];
				continue;
			}
	
			// "link" attributes are always cleared for new data definitions
			// that introduce new links, except when explicitly adding.
			if ($key == "link" && !$seenLinkAttribute && !$add) {
				$this->links = [];
				$seenLinkAttribute = true;
			}
			// Handle the attributes which can be "removed."
			if ($key == "link" && $child->size() > $valueIndex + 1) {
				$fromName = $child->getToken($valueIndex);
				$toName = $child->getToken($valueIndex + 1);
				$from = GameData::Systems()[$fromName];
				$to = GameData::Systems()[$toName];
				if ($remove) {
					// Only erase if the link is an exact match.
					if (isset($this->links[$fromName]) && $this->links[$fromName] == $to) {
						unset($this->links[$fromName]);
					} else {
						$child->printTrace("Unable to remove non-existent link:");
					}
				} else {
					$this->links[$fromName] = $to;
				}
			} else if ($key == "mappable") {
				$this->mappable = !$remove;
			} else if ($key == "display name") {
				if ($remove) {
					$this->name = "???";
				} else if ($hasValue) {
					$this->name = $value;
				} else {
					$child->printTrace("Missing value for attribute:");
				}
			} else if ($key == "color" && ($hasValue || $remove)) {
				if ($remove) {
					$this->linkColor = GameData::Colors()[self::DEFAULT_WORMHOLE_COLOR];
				} else if ($child->size() >= 3 + $valueIndex) {
					$this->linkColor = new Color($child->getValue($valueIndex), $child->getValue($valueIndex + 1), $child->getValue($valueIndex + 2));
					$this->linkColor->name = 'wormhole: '.$this->trueName;
				} else if ($child->size() >= 1 + $valueIndex) {
					$this->linkColor = GameData::Colors()[$child->getToken($valueIndex)];
				} else {
					$child->printTrace("Warning: skipping malformed \"color\" node:");
				}
			} else if ($remove) {
				$child->printTrace("Cannot \"remove\" a specific value from the given key:");
			} else {
				$child->printTrace("Skipping unrecognized attribute:");
			}
		}
	}
	
	public function loadFromPlanet(Planet $planet) {
		$this->planet = $planet;
		$this->mappable = $planet->getDescription() != '';
		$this->generateLinks();
		$this->isAutogenerated = true;
		$this->isDefined = true;
	}
	
	public function isValid(): bool {
		if (!$this->isDefined) {
			return false;
		}
		if (!$this->planet || !$this->planet->isValid()) {
			return false;
		}
		
		foreach ($this->links as $fromName => $toSystem) {
			if (!$toSystem->isValid()) {
				return false;
			}
			$fromSystem = GameData::Systems()[$fromName];
			if (!$fromSystem->isValid()) {
				return false;
			}
		}
	
		return true;
	}
	
	public function getPlanet(): Planet {
		return $this->planet;
	}
	
	public function getName(): string {
		return $this->name;
	}
	
	public function getTrueName(): string {
		return $this->trueName;
	}
	
	public function isMappable(): bool {
		return $this->mappable;
	}
	
	public function getLinkColor(): Color {
		return $this->linkColor;
	}
	
	public function isAutogenerated(): bool {
		return $this->isAutogenerated;
	}
	
	public function getSourceName(): string {
		return $this->sourceName;
	}
	public function setSourceName(string $sourceName): self {
		$this->sourceName = $sourceName;
		return $this;
	}
	
	public function getSourceFile(): string {
		return $this->sourceFile;
	}
	public function setSourceFile(string $sourceFile): self {
		$this->sourceFile = $sourceFile;
		return $this;
	}
	
	public function getSourceVersion(): string {
		return $this->sourceVersion;
	}
	public function setSourceVersion(string $sourceVersion): self {
		$this->sourceVersion = $sourceVersion;
		return $this;
	}
	
	public function getWormholeSource(System $to): System {
		foreach ($this->links as $fromName => $toSystem) {
			if ($toSystem == $to) {
				return GameData::Systems()[$fromName];
			}
		}
		return $to;
	}
	
	public function getWormholeDestination(System $from): System {
		foreach ($this->links as $fromName => $toSystem) {
			if ($fromName == $from->getName()) {
				return $toSystem;
			}
		}
		return $from;
	}
	
	public function getLinks(): array {
		return $this->links;
	}
	
	public function setPlanet(Planet $planet): void {
		$this->planet = $planet;
	}
	
	public function GenerateLinks(): void {
		// Clear any previous links since we're regenerating every link.
		$this->links = [];
	
		// Wormhole links form a closed loop through every system the planet is in.
		for ($i = 0; $i < count($this->planet->getSystems()); ++$i) {
			$next = $i == count($this->planet->getSystems()) - 1 ? 0 : $i + 1;
			// But check whether the wormhole in the given system has a sprite.
			// If not, this is a one way wormhole that shouldn't be linked.
			if ($this->planet->getSystems()[$i]->findStellar($this->planet)->getSprite()) {
				$this->links[$this->planet->getSystems()[$i]->getName()] = $this->planet->getSystems()[$next];
			}
		}
	}
	
	public function toJSON($justArray=false): array|string {
		$jsonArray = [];
		$jsonArray['isDefined'] = $this->isDefined;
		$jsonArray['isAutogenerated'] = $this->isAutogenerated;
		
		$jsonArray['planet'] = $this->planet?->toJSON(true);
		$jsonArray['name'] = $this->name;
		$jsonArray['trueName'] = $this->trueName;
		$jsonArray['mappable'] = $this->mappable;
		$jsonArray['linkColor'] = $this->linkColor->toJSON(true);
		
		$jsonArray['links'] = [];
		foreach ($this->links as $fromName => $toSystem) {
			$jsonArray['links'][$fromName] = $toSystem->getName();
		}
		
		$jsonArray['source'] = ['name'=>$this->sourceName,'file'=>$this->sourceFile,'version'=>$this->sourceVersion];
		
		if ($justArray) {
			return $jsonArray;
		}
		return json_encode($jsonArray);
	}

    /**
     * @return Collection<int, WormholeLink>
     */
    public function getLinkObjects(): Collection
    {
        return $this->linkObjects;
    }

    public function addLinkObject(WormholeLink $linkObject): self
    {
        if (!$this->linkObjects->contains($linkObject)) {
            $this->linkObjects->add($linkObject);
            $linkObject->setWormhole($this);
        }

        return $this;
    }

    public function removeLinkObject(WormholeLink $linkObject): self
    {
        if ($this->linkObjects->removeElement($linkObject)) {
            // set the owning side to null (unless already changed)
            if ($linkObject->getWormhole() === $this) {
                $linkObject->setWormhole(null);
            }
        }

        return $this;
    }

}